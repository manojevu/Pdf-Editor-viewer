<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Editor (Stable V5)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        :root { --primary-color: #3498db; --secondary-color: #2c3e50; --success-color: #27ae60; --danger-color: #e74c3c; --light-gray: #f5f5f5; --border-color: #ddd; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--light-gray); }
        .header { background: var(--secondary-color); color: white; padding: 1rem; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .container { max-width: 1200px; margin: 0 auto; padding: 2rem; }
        .upload-zone { border: 3px dashed var(--primary-color); border-radius: 10px; padding: 3rem; text-align: center; background: white; margin-bottom: 2rem; transition: all 0.3s ease; cursor: pointer; }
        .upload-zone:hover { border-color: #2980b9; }
        .upload-zone.dragover { border-color: var(--success-color); }
        .file-input { display: none; }
        .editor-area { display: none; }
        .editor-area.active { display: block; }
        .toolbar-container { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .toolbar-main, .toolbar-contextual { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; }
        .toolbar-contextual { border-top: 1px solid var(--border-color); margin-top: 0.5rem; padding-top: 0.5rem; min-height: 40px; }
        .toolbar-main .btn.active { background: #2980b9; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2); }
        .btn { background: var(--primary-color); color: white; border: none; padding: 0.7rem 1.5rem; border-radius: 5px; cursor: pointer; font-size: 0.9rem; transition: background 0.3s ease; }
        .btn:hover:not(:disabled) { background: #2980b9; }
        .btn:disabled { background: #bdc3c7; cursor: not-allowed; }
        .btn.danger { background: var(--danger-color); }
        .btn.danger:hover:not(:disabled) { background: #c0392b; }
        .btn.success { background: var(--success-color); }
        .btn.success:hover:not(:disabled) { background: #219a52; }
        
        /* --- CSS FIX FOR CENTERING STARTS HERE --- */
        .viewer-wrapper {
            /* This new wrapper uses Flexbox to center the entire viewer block */
            display: flex;
            justify-content: center;
        }
        .pdf-viewer {
            /* This is the white box. No margin needed as the parent handles centering. */
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            width: fit-content; /* Shrinks to fit the content inside */
        }
        .canvas-wrapper {
            position: relative; /* This is the anchor for positioning the overlay canvas */
            line-height: 0; /* Removes extra space below the canvas */
        }
        #pdfCanvas { 
            border: 1px solid var(--border-color);
            display: block;
        }
        #overlayCanvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            pointer-events: none;
        }
        /* --- CSS FIX ENDS HERE --- */

        .page-controls { text-align: center; margin-bottom: 1.5rem; }
        .page-controls input { width: 60px; text-align: center; }
        .text-input-overlay { position: absolute; display: none; z-index: 1000; }
        .status { text-align: center; padding: 1rem; margin: 1rem 0; border-radius: 5px; display: none; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; display: block; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; display: block; }
    </style>
</head>
<body>
    <div class="header"><h1>PDF Editor (Stable V5)</h1><p>Local, in-browser PDF editing</p></div>
    <div class="container">
        <div class="upload-zone" id="uploadZone"><p><strong>Drop your PDF file here</strong><br>or click to browse</p><input type="file" id="fileInput" class="file-input" accept=".pdf"></div>
        <div class="status" id="status"></div>
        <div class="editor-area" id="editorArea">
            <div class="toolbar-container">
                <div class="toolbar-main">
                    <button class="btn" id="textBtn">Text</button>
                    <button class="btn" id="drawBtn">Draw</button>
                    <button class="btn" id="highlightBtn">Highlight</button>
                    <button class="btn" id="rectBtn">Rectangle</button>
                    <span style="flex-grow: 1;"></span>
                    <button class="btn" id="undoBtn" disabled>Undo</button>
                    <button class="btn" id="redoBtn" disabled>Redo</button>
                    <button class="btn danger" onclick="deletePage()">Delete Page</button>
                    <button class="btn" onclick="rotatePage()">Rotate</button>
                    <button class="btn success" onclick="downloadPDF()">Download</button>
                    <button class="btn danger" onclick="resetEditor()">Reset</button>
                </div>
                <div class="toolbar-contextual" id="contextualToolbar"></div>
            </div>
            <!-- HTML STRUCTURE CHANGE FOR CENTERING -->
            <div class="viewer-wrapper">
                <div class="pdf-viewer">
                    <div class="page-controls">
                        <button class="btn" id="prevPageBtn" onclick="previousPage()">Previous</button>
                        <span>Page <input type="number" id="pageNum" value="1" min="1" onchange="goToPage()"> of <span id="pageCount">1</span></span>
                        <button class="btn" id="nextPageBtn" onclick="nextPage()">Next</button>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="pdfCanvas"></canvas>
                        <canvas id="overlayCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="text-input-overlay" id="textInputOverlay"><input type="text" id="textInput" placeholder="Enter text..."><button class="btn" onclick="confirmAddText()">Add</button><button class="btn" onclick="cancelAddText()">Cancel</button></div>
    </div>

<script>
    const { PDFDocument, rgb, cmyk, degrees } = PDFLib;
    let pdfDoc = null, pdfLibDoc = null;
    let currentPage = 1, totalPages = 0, scale = 1.5;
    let pdfCanvas, pdfCtx, overlayCanvas, overlayCtx;
    let currentMode = 'none', isDrawing = false, startCoords = {}, drawingPoints = [];
    let toolSettings = { textColor: '#000000', fontSize: 16, drawColor: '#ff0000', lineWidth: 2, highlightColor: '#ffff00' };
    let historyStack = [], historyIndex = -1;

    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;

    document.addEventListener('DOMContentLoaded', () => {
        pdfCanvas = document.getElementById('pdfCanvas'); pdfCtx = pdfCanvas.getContext('2d');
        overlayCanvas = document.getElementById('overlayCanvas'); overlayCtx = overlayCanvas.getContext('2d');
        const up = document.getElementById('uploadZone'), fIn = document.getElementById('fileInput');
        up.addEventListener('click', () => fIn.click());
        up.addEventListener('dragover', e => { e.preventDefault(); up.classList.add('dragover'); });
        up.addEventListener('dragleave', e => { e.preventDefault(); up.classList.remove('dragover'); });
        up.addEventListener('drop', e => { e.preventDefault(); up.classList.remove('dragover'); const f = e.dataTransfer.files[0]; if (f) loadPDF(f); });
        fIn.addEventListener('change', e => { const f = e.target.files[0]; if (f) loadPDF(f); });
        const vC = document.querySelector('.canvas-wrapper'); // Event listener is now on the canvas-wrapper
        vC.addEventListener('mousedown', handleMouseDown); vC.addEventListener('mousemove', handleMouseMove);
        vC.addEventListener('mouseup', handleMouseUp); vC.addEventListener('mouseleave', handleMouseUp);
        vC.addEventListener('click', handleCanvasClick);
        document.getElementById('textBtn').addEventListener('click', () => setMode('text'));
        document.getElementById('drawBtn').addEventListener('click', () => setMode('draw'));
        document.getElementById('highlightBtn').addEventListener('click', () => setMode('highlight'));
        document.getElementById('rectBtn').addEventListener('click', () => setMode('rect'));
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);
    });

    async function loadPDF(file) {
        try {
            showStatus('Reading file...', 'success');
            const arrayBuffer = await file.arrayBuffer();
            pdfLibDoc = await PDFDocument.load(arrayBuffer);
            const initialPdfBytes = await pdfLibDoc.save();
            pdfDoc = await pdfjsLib.getDocument({ data: initialPdfBytes }).promise;
            
            totalPages = pdfDoc.numPages;
            historyStack = [initialPdfBytes];
            historyIndex = 0;
            updateUndoRedoButtons();

            document.getElementById('uploadZone').style.display = 'none';
            document.getElementById('editorArea').classList.add('active');

            currentPage = 1;
            await updatePageUI();
            showStatus('PDF loaded successfully!', 'success');

        } catch (error) {
            console.error('CRITICAL FAILURE during PDF load:', error);
            showStatus(`Error: Could not load this PDF. It may be corrupted or password-protected.`, 'error');
            resetEditor();
        }
    }

    async function renderPage(pageNum) {
        isDrawing = false;
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale });
        pdfCanvas.height = viewport.height; pdfCanvas.width = viewport.width;
        overlayCanvas.height = viewport.height; overlayCanvas.width = viewport.width;
        await page.render({ canvasContext: pdfCtx, viewport }).promise;
    }

    async function updatePageUI() {
        if (currentPage > totalPages) currentPage = totalPages;
        if (currentPage < 1) currentPage = 1;
        document.getElementById('pageNum').value = currentPage;
        document.getElementById('pageCount').textContent = totalPages;
        document.getElementById('prevPageBtn').disabled = currentPage <= 1;
        document.getElementById('nextPageBtn').disabled = currentPage >= totalPages;
        await renderPage(currentPage);
    }
    async function previousPage() { if (currentPage > 1) { currentPage--; await updatePageUI(); } }
    async function nextPage() { if (currentPage < totalPages) { currentPage++; await updatePageUI(); } }
    async function goToPage() { const num = parseInt(document.getElementById('pageNum').value); if (num >= 1 && num <= totalPages) { currentPage = num; await updatePageUI(); } }
    
    async function saveState() {
        const bytes = await pdfLibDoc.save();
        historyStack = historyStack.slice(0, historyIndex + 1);
        historyStack.push(bytes);
        historyIndex++;
        updateUndoRedoButtons();
    }
    async function loadState(stateBytes) {
        pdfLibDoc = await PDFDocument.load(stateBytes);
        pdfDoc = await pdfjsLib.getDocument({ data: stateBytes.slice(0) }).promise;
        totalPages = pdfDoc.numPages;
        await updatePageUI();
    }
    async function undo() { if (historyIndex > 0) { historyIndex--; await loadState(historyStack[historyIndex]); updateUndoRedoButtons(); } }
    async function redo() { if (historyIndex < historyStack.length - 1) { historyIndex++; await loadState(historyStack[historyIndex]); updateUndoRedoButtons(); } }
    function updateUndoRedoButtons() {
        document.getElementById('undoBtn').disabled = historyIndex <= 0;
        document.getElementById('redoBtn').disabled = historyIndex >= historyStack.length - 1;
    }

    function setMode(mode) { currentMode = currentMode === mode ? 'none' : mode; updateToolbar(); }
    function updateToolbar() {
        document.querySelectorAll('.toolbar-main .btn').forEach(b => b.classList.remove('active'));
        if (currentMode !== 'none') document.getElementById(`${currentMode}Btn`).classList.add('active');
        const wrapper = document.querySelector('.canvas-wrapper');
        wrapper.style.cursor = 'default';
        if (currentMode !== 'none' && currentMode !== 'text') wrapper.style.cursor = 'crosshair';
        if (currentMode === 'text') wrapper.style.cursor = 'text';

        const ctb = document.getElementById('contextualToolbar');
        let html = '';
        if (currentMode === 'text') html = `<div>Font Size: <input type="number" value="${toolSettings.fontSize}" onchange="toolSettings.fontSize = this.value;"> Color: <input type="color" value="${toolSettings.textColor}" onchange="toolSettings.textColor = this.value;"></div>`;
        if (currentMode === 'draw' || currentMode === 'rect') html = `<div>Line Width: <input type="range" min="1" max="20" value="${toolSettings.lineWidth}" onchange="toolSettings.lineWidth = this.value;"> Color: <input type="color" value="${toolSettings.drawColor}" onchange="toolSettings.drawColor = this.value;"></div>`;
        if (currentMode === 'highlight') html = `<div>Highlight Color: <input type="color" value="${toolSettings.highlightColor}" onchange="toolSettings.highlightColor = this.value;"></div>`;
        ctb.innerHTML = html;
    }

    function getMouseCoords(e) { const r = e.currentTarget.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    function handleMouseDown(e) { if (currentMode === 'none' || currentMode === 'text') return; isDrawing = true; startCoords = getMouseCoords(e); drawingPoints = [startCoords]; overlayCanvas.style.pointerEvents = 'auto'; }
    function handleMouseMove(e) { if (!isDrawing) return; const c = getMouseCoords(e); overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); if (currentMode === 'draw') { drawingPoints.push(c); overlayCtx.beginPath(); overlayCtx.moveTo(drawingPoints[0].x, drawingPoints[0].y); drawingPoints.forEach(p => overlayCtx.lineTo(p.x, p.y)); overlayCtx.strokeStyle = toolSettings.drawColor; overlayCtx.lineWidth = toolSettings.lineWidth; overlayCtx.stroke(); } else if (currentMode === 'highlight' || currentMode === 'rect') { const r = { w: c.x - startCoords.x, h: c.y - startCoords.y }; if (currentMode === 'highlight') { overlayCtx.globalAlpha = 0.3; overlayCtx.fillStyle = toolSettings.highlightColor; overlayCtx.fillRect(startCoords.x, startCoords.y, r.w, r.h); overlayCtx.globalAlpha = 1.0; } else { overlayCtx.strokeStyle = toolSettings.drawColor; overlayCtx.lineWidth = toolSettings.lineWidth; overlayCtx.strokeRect(startCoords.x, startCoords.y, r.w, r.h); } } }
    async function handleMouseUp(e) { if (!isDrawing) return; isDrawing = false; overlayCanvas.style.pointerEvents = 'none'; overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); const page = pdfLibDoc.getPage(currentPage - 1); const { height } = page.getSize(); const toPdfPath = pts => pts.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x/scale} ${height-(p.y/scale)}`).join(' '); const toPdfRect = (s, end) => ({ x:Math.min(s.x,end.x)/scale, y:height-Math.max(s.y,end.y)/scale, width:Math.abs(end.x-s.x)/scale, height:Math.abs(end.y-s.y)/scale }); if (currentMode === 'draw') page.drawSvgPath(toPdfPath(drawingPoints), { borderColor: rgb(...hexToRgb(toolSettings.drawColor)), borderWidth: parseInt(toolSettings.lineWidth) }); else if (currentMode === 'highlight') page.drawRectangle({ ...toPdfRect(startCoords, getMouseCoords(e)), color: rgb(...hexToRgb(toolSettings.highlightColor)), opacity: 0.3 }); else if (currentMode === 'rect') page.drawRectangle({ ...toPdfRect(startCoords, getMouseCoords(e)), borderColor: rgb(...hexToRgb(toolSettings.drawColor)), borderWidth: parseInt(toolSettings.lineWidth), color: cmyk(0,0,0,0) }); await saveState(); await loadState(historyStack[historyIndex]); }
    function handleCanvasClick(e) { if (currentMode !== 'text') return; const c = getMouseCoords(e); const o = document.getElementById('textInputOverlay'); o.style.display = 'block'; o.style.left = `${e.pageX}px`; o.style.top = `${e.pageY}px`; o.dataset.x = c.x; o.dataset.y = c.y; document.getElementById('textInput').focus(); }
    
    async function confirmAddText() { const txt = document.getElementById('textInput').value.trim(); if (!txt) return cancelAddText(); const {x, y} = document.getElementById('textInputOverlay').dataset; const page = pdfLibDoc.getPage(currentPage - 1); page.drawText(txt, { x: parseFloat(x)/scale, y: page.getHeight() - (parseFloat(y)/scale), size: parseInt(toolSettings.fontSize), color: rgb(...hexToRgb(toolSettings.textColor)) }); await saveState(); await loadState(historyStack[historyIndex]); cancelAddText(); }
    function cancelAddText() { document.getElementById('textInputOverlay').style.display = 'none'; document.getElementById('textInput').value = ''; }
    async function deletePage() { if (totalPages <= 1) return; pdfLibDoc.removePage(currentPage - 1); await saveState(); await loadState(historyStack[historyIndex]); }
    async function rotatePage() { const p = pdfLibDoc.getPage(currentPage - 1); p.setRotation(degrees((p.getRotation().angle + 90) % 360)); await saveState(); await loadState(historyStack[historyIndex]); }
    async function downloadPDF() { const bytes = await pdfLibDoc.save(); const blob = new Blob([bytes], { type: 'application/pdf' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = `edited-${Date.now()}.pdf`; link.click(); URL.revokeObjectURL(link.href); }
    function resetEditor() { document.getElementById('editorArea').classList.remove('active'); document.getElementById('uploadZone').style.display = 'block'; document.getElementById('fileInput').value = ''; pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height); setMode('none'); historyStack = []; historyIndex = -1; hideStatus(); }
    function hexToRgb(h) { const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h); return r ? [parseInt(r[1], 16)/255, parseInt(r[2], 16)/255, parseInt(r[3], 16)/255] : [0,0,0]; }
    function showStatus(msg, type) { const el = document.getElementById('status'); el.textContent = msg; el.className = `status ${type}`; if (type === 'success') setTimeout(hideStatus, 4000); }
    function hideStatus() { document.getElementById('status').className = 'status'; }
</script>
</body>
</html>